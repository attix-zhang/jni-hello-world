plugins {
    // Apply the java plugin to add support for Java
    id 'java'

    // Apply the application plugin to add support for building a CLI application.
    id 'application'
}

application {
    // Define the main class for the application.
    mainClassName = 'jni.hello.world.App'
}

def generateJniWorkingDir = file("${buildDir}/tmp/generateJniHeaders")

// Using javah to generate header file. In Java 11, we need to use `javac -h <generate_header_dir>` to generate header file
//task generateJniHeaders(type: Exec) {
//    generateJniWorkingDir.mkdirs()
//
//    workingDir generateJniWorkingDir
//
//    def classpath = sourceSets.main.java.classesDirectory
//
//    commandLine "javah", "-classpath", classpath.get(), "-jni", "jni.hello.world.App"
//
//    dependsOn compileJava
//}

compileJava {
    // Using 'javac -h <dir>' to generate native header files
    options.compilerArgs << "-h" << "${generateJniWorkingDir}"
}

def gccCompileDir = file("${buildDir}/tmp/gccCompileDir");

task copyHeaderAndCppFiles(type: Copy) {
    from "${generateJniWorkingDir}/jni_hello_world_App.h", "${projectDir}/jni_hello_world_App.cpp"
    into gccCompileDir

    dependsOn compileJava
}

task generateJniLib(type: Exec) {
    workingDir gccCompileDir

    def javaHome = "${System.env.JAVA_HOME}"

    commandLine "gcc",
        "-I${javaHome}/include/", "-I${javaHome}/include/darwin/",
        "-dynamiclib", "jni_hello_world_App.cpp",
        "-o", "libHelloWorldImpl.dylib"

    dependsOn copyHeaderAndCppFiles
}

run {
    workingDir gccCompileDir
    dependsOn generateJniLib
}
